#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(non_snake_case)]
#![allow(arithmetic_overflow)]

use crate::constants::Val;
use std::collections::VecDeque;

// largest 16-bit prime number
const BASE: u32 = 65521;

#[derive(Debug)]
pub struct Adler32 {
    s1: u16, 
    s2: u16,
    count: usize,
    rolled_out_byte: u8,
    window: VecDeque<u8>,
}

impl Adler32 {
    /// Creates an empty Adler32 ctx (with hash 1).
    pub fn new() -> Self {
        Self {
            s1: 0u16,
            s2: 0u16,
            count: 0,
            rolled_out_byte: 0,
            window: VecDeque::new(),
        }
    }

    pub fn window(&self) -> Vec<u8> {
        Vec::from(self.window.clone())
    }

    pub fn roll_in(&mut self, byte: u8) -> &mut Self {
        let mut tmp_s1 = self.s1 as u32;
        let mut tmp_s2 = self.s2 as u32;
        
        tmp_s1 = (tmp_s1 + byte as u32) % BASE;
        tmp_s2 = (tmp_s2 + tmp_s1) % BASE;
        
        self.s1 = tmp_s1 as u16;
        self.s2 = tmp_s2 as u16;

        self.window.push_back(byte);
        self.count += 1;
        
        self
    }

    pub fn roll_out(& mut self) -> &mut Self {
        let len = self.window.len() as u32;
        let res = self.window.pop_front();
        if res.is_none() {
            self.count = 0;
            return self;
        }
        self.rolled_out_byte = res.unwrap();

        let mut tmp_s1 = self.s1 as u32;
        let mut tmp_s2 = self.s2 as u32;
        let rolled_out_byte = self.rolled_out_byte as u32;

        tmp_s1 = (tmp_s1 - rolled_out_byte) % BASE;
        tmp_s2 = (tmp_s2 - (len * rolled_out_byte)) % BASE;
        
        self.s1 = tmp_s1 as u16;
        self.s2 = tmp_s2 as u16;
        
        self.count -= 1;
        self
    }

    pub fn write_bytes(&mut self, bytes: &[u8]) -> &mut Self {
        let mut tmp_s1 = self.s1 as u32;
        let mut tmp_s2 = self.s2 as u32;
        let len = bytes.len() as u32;

        for (i, byte) in bytes.into_iter().enumerate() {
            tmp_s1 += *byte as u32;
            tmp_s2 += ((len - (i as u32)) * (*byte as u32));
            self.count += 1;
        }
        
        self.s1 = (tmp_s1 % BASE) as u16;
        self.s2 = (tmp_s2 % BASE) as u16;

        self
    }

    pub fn sum32(&self) -> u32 {
        (self.s2 as u32)  << 16 | (self.s1 as u32) & 0xFFFF
    }

    pub fn get_s1_s2_from_hash(h: u32) -> (u16, u16) {
        (h as u16, (h >> 16) as u16)
    }
}


#[cfg(test)]
mod test {
    use super::*;
    
    // #[test]
    fn ut_testVectors_works() {
        fn do_test(v: u32, bytes: &[u8]) {
            let mut adler = Adler32::new();
            adler.write_bytes(&bytes);
            assert_eq!(adler.sum32(), v);
        }

        do_test(0x00000000, b"");
        do_test(6357089, b"a");
        do_test(1621164326, b"abc");
        do_test(3032745349, b"message digest");
        do_test(2436762399, b"abcdefghijklmnopqrstuvwxyz");
        do_test(
            3920696587,
            b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        );
        do_test(
            2162721,
            b"12345678901234567890123456789012345678901234567890123456789012345678901234567890",
        );
    }


    #[test]
    fn ut_rolling_works() {
        fn do_test() { // a: &[u8], b: &[u8]
            const a: &[u8] = &"dog!".as_bytes();
            const b: &[u8] = &"a dog!".as_bytes();
            
            let mut adler1 = Adler32::new();
            let mut adler2 = Adler32::new();
            
            let hash1 = adler1.roll_in(a[0]).sum32();//adler1.write_bytes(a).sum32();

            for c in b {
                adler2.roll_in(*c);
            }

            assert_eq!(adler2.window(), b);
            
            adler2.roll_out();
            let mut c = adler2.rolled_out_byte;
            assert_eq!(c, b[0]);
            assert_eq!(adler2.window(), b[1..]);
            adler2.roll_out();
            c = adler2.rolled_out_byte;
            assert_eq!(c, b[1]);
            assert_eq!(adler2.window(), b[2..]);
            
            assert_eq!(Adler32::get_s1_s2_from_hash(adler2.sum32()), (adler1.s1, adler1.s2)); // b[3..]

            assert_eq!(hash1, adler2.sum32());
        }
        // do_test(b"a", b"b");
        // do_test(b"", b"this a test");
        // do_test(b"th", b"is a test");
        // do_test(b"this a ", b"test");
        do_test();
    }
}